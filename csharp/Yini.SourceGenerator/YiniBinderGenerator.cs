using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Yini.SourceGenerator
{
    [Generator]
    public class YiniBinderGenerator : ISourceGenerator
    {
        private const string AttributeText = @"
// <auto-generated/>
using System;
namespace Yini
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class YiniBindableAttribute : Attribute
    {
    }
}";

        public void Initialize(GeneratorInitializationContext context)
        {
            // Inject the attribute source into the compilation
            context.RegisterForPostInitialization((i) => i.AddSource("YiniBindableAttribute.g.cs", AttributeText));

            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // Retrieve the populated receiver
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            // Get the compilation and the attribute symbol
            Compilation compilation = context.Compilation;
            INamedTypeSymbol attributeSymbol = compilation.GetTypeByMetadataName("Yini.YiniBindableAttribute");

            foreach (ClassDeclarationSyntax classSyntax in receiver.CandidateClasses)
            {
                SemanticModel model = compilation.GetSemanticModel(classSyntax.SyntaxTree);
                if (!(model.GetDeclaredSymbol(classSyntax) is INamedTypeSymbol classSymbol))
                    continue;

                // Check if the class has the [YiniBindable] attribute
                if (classSymbol.GetAttributes().Any(ad => ad.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default)))
                {
                    string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
                    var source = GenerateBinderClass(classSymbol, namespaceName);
                    context.AddSource($"{classSymbol.Name}_YiniBinder.g.cs", SourceText.From(source, Encoding.UTF8));
                }
            }
        }

        private string GenerateBinderClass(INamedTypeSymbol classSymbol, string namespaceName)
        {
            var className = classSymbol.Name;
            var properties = classSymbol.GetMembers().OfType<IPropertySymbol>()
                                       .Where(p => p.SetMethod != null && p.GetMethod != null);

            var sb = new StringBuilder();
            sb.Append($@"// <auto-generated/>
using Yini;

namespace {namespaceName}
{{
    public partial class {className}
    {{
        /// <summary>
        /// Binds data from a YINI file to this instance using a high-performance,
        /// reflection-free method generated at compile time.
        /// </summary>
        public void BindFromYini(YiniManager manager, string section)
        {{
");

            foreach (var prop in properties)
            {
                string propertyName = prop.Name;
                string propertyType = prop.Type.ToDisplayString();

                // Check for [YiniKey] attribute to allow custom key names
                var keyAttr = prop.GetAttributes().FirstOrDefault(ad => ad.AttributeClass.Name == "YiniKeyAttribute");
                string yiniKey = keyAttr?.ConstructorArguments.FirstOrDefault().Value?.ToString() ?? propertyName.ToLower();

                string bindingMethod;
                switch (propertyType)
                {
                    case "string":
                        bindingMethod = $"manager.GetString(section, \"{yiniKey}\", this.{propertyName})";
                        break;
                    case "bool":
                        bindingMethod = $"manager.GetBool(section, \"{yiniKey}\", this.{propertyName})";
                        break;
                    case "int":
                        bindingMethod = $"(int)manager.GetDouble(section, \"{yiniKey}\", this.{propertyName})";
                        break;
                    case "float":
                        bindingMethod = $"(float)manager.GetDouble(section, \"{yiniKey}\", this.{propertyName})";
                        break;
                    case "double":
                        bindingMethod = $"manager.GetDouble(section, \"{yiniKey}\", this.{propertyName})";
                        break;
                    default:
                        // Skip unsupported types for now
                        continue;
                }

                sb.AppendLine($"            this.{propertyName} = {bindingMethod};");
            }

            sb.Append(@"
        }
    }
}
");
            return sb.ToString();
        }
    }

    /// <summary>
    /// Created on demand before each generation pass
    /// </summary>
    class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

        /// <summary>
        /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
        /// </summary>
        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Any class with at least one attribute is a candidate for generation
            if (syntaxNode is ClassDeclarationSyntax classDeclarationSyntax
                && classDeclarationSyntax.AttributeLists.Count > 0)
            {
                CandidateClasses.Add(classDeclarationSyntax);
            }
        }
    }
}
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Yini.SourceGenerator
{
    [Generator]
    public class YiniBinderGenerator : ISourceGenerator
    {
        private const string AttributeText = @"
// <auto-generated/>
using System;
namespace Yini
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class YiniBindableAttribute : Attribute
    {
    }
}";

        public void Initialize(GeneratorInitializationContext context)
        {
            // Inject the attribute source into the compilation
            context.RegisterForPostInitialization((i) => i.AddSource("YiniBindableAttribute.g.cs", AttributeText));

            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // Retrieve the populated receiver
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            // Get the compilation and the attribute symbol
            Compilation compilation = context.Compilation;
            INamedTypeSymbol attributeSymbol = compilation.GetTypeByMetadataName("Yini.YiniBindableAttribute");

            foreach (ClassDeclarationSyntax classSyntax in receiver.CandidateClasses)
            {
                SemanticModel model = compilation.GetSemanticModel(classSyntax.SyntaxTree);
                if (!(model.GetDeclaredSymbol(classSyntax) is INamedTypeSymbol classSymbol))
                    continue;

                // Check if the class has the [YiniBindable] attribute
                if (classSymbol.GetAttributes().Any(ad => ad.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default)))
                {
                    string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
                    var source = GenerateBinderClass(classSymbol, namespaceName);
                    context.AddSource($"{classSymbol.Name}_YiniBinder.g.cs", SourceText.From(source, Encoding.UTF8));
                }
            }
        }

        private string GenerateBinderClass(INamedTypeSymbol classSymbol, string namespaceName)
        {
            var className = classSymbol.Name;
            var properties = classSymbol.GetMembers().OfType<IPropertySymbol>()
                                             .Where(p => p.SetMethod != null && p.GetMethod != null);

            var sb = new StringBuilder();
            sb.Append($@"// <auto-generated/>
using Yini;
using System.Collections.Generic;

namespace {namespaceName}
{{
    public partial class {className}
    {{
        /// <summary>
        /// Binds data from a YINI file to this instance using a high-performance,
        /// reflection-free method generated at compile time.
        /// </summary>
        public void BindFromYini(YiniManager manager, string section)
        {{
");

            // *** 核心修复逻辑在这里：检查 Key 是否存在，确保不覆盖默认值 ***
            foreach (var prop in properties)
            {
                var propType = prop.Type as INamedTypeSymbol;
                if (propType == null) continue;

                var keyAttr = prop.GetAttributes().FirstOrDefault(ad => ad.AttributeClass.Name == "YiniKeyAttribute");
                string yiniKey = keyAttr?.ConstructorArguments.FirstOrDefault().Value?.ToString() ?? prop.Name.ToLower();

                string bindingMethod = GetBindingMethod(propType, yiniKey);
                if (bindingMethod != null)
                {
                    // 检查整个 Section 是否存在。如果 Section 不存在，HasKey 应该返回 false。
                    // 但是，HasKey 通常只检查 Key。为了涵盖 MissingSection 的情况，
                    // 我们假设 YiniManager.HasKey 在 Section 不存在时也能处理。
                    
                    sb.AppendLine($"            if (manager.HasKey(section, \"{yiniKey}\"))");
                    sb.AppendLine("            {");

                    bool isNonNullableValueType = propType.IsValueType && !(propType.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T);

                    if (isNonNullableValueType)
                    {
                        // 对于 int/bool 等非可空值类型，直接赋值
                        sb.AppendLine($"                this.{prop.Name} = {bindingMethod};");
                    }
                    else
                    {
                        // 对于 string/可空值类型，使用 ?? 运算符来保留现有值，
                        // 以防 Get... 方法返回 null。
                        sb.AppendLine($"                this.{prop.Name} = {bindingMethod} ?? this.{prop.Name};");
                    }
                    sb.AppendLine("            }");
                }
            }
            // *** 核心修复逻辑结束 ***

            sb.Append(@"
        }
    }
}
");
            return sb.ToString();
        }

        private string GetBindingMethod(INamedTypeSymbol propType, string yiniKey)
        {
            string typeName = propType.ToDisplayString();

            if (propType.IsGenericType && (propType.Name == "List" || propType.Name == "IList") && propType.TypeArguments.Length == 1)
            {
                var elementType = propType.TypeArguments[0];
                return $"manager.GetList<{elementType.ToDisplayString()}>(section, \"{yiniKey}\")";
            }

            if (propType.IsGenericType && (propType.Name == "Dictionary" || propType.Name == "IDictionary") && propType.TypeArguments.Length == 2 && propType.TypeArguments[0].SpecialType == SpecialType.System_String)
            {
                var valueType = propType.TypeArguments[1];
                return $"manager.GetDictionary<string, {valueType.ToDisplayString()}>(section, \"{yiniKey}\")";
            }

            switch (typeName)
            {
                case "string":
                case "System.String":
                    // 移除默认值参数
                    return $"manager.GetString(section, \"{yiniKey}\")";
                case "bool":
                case "System.Boolean":
                    // 移除默认值参数
                    // 注意：这里我们假设 YiniManager 有 GetBool(string, string) 方法
                    return $"manager.GetBool(section, \"{yiniKey}\")";
                case "int":
                case "System.Int32":
                    // 移除默认值参数
                    // 为了与您的原始代码一致，我们保留 GetDouble 并进行转换
                    return $"(int)manager.GetDouble(section, \"{yiniKey}\")";
                case "float":
                case "System.Single":
                    // 移除默认值参数
                    return $"(float)manager.GetDouble(section, \"{yiniKey}\")";
                case "double":
                case "System.Double":
                    // 移除默认值参数
                    return $"manager.GetDouble(section, \"{yiniKey}\")";
                default:
                    return null;
            }
        }
    }

    /// <summary>
    /// Created on demand before each generation pass
    /// </summary>
    class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

        /// <summary>
        /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
        /// </summary>
        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Any class with at least one attribute is a candidate for generation
            if (syntaxNode is ClassDeclarationSyntax classDeclarationSyntax
                && classDeclarationSyntax.AttributeLists.Count > 0)
            {
                CandidateClasses.Add(classDeclarationSyntax);
            }
        }
    }
}

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Yini.SourceGenerator
{
    [Generator]
    public class YiniBinderGenerator : ISourceGenerator
    {
        private const string AttributeText = @"
// <auto-generated/>
using System;
namespace Yini
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class YiniBindableAttribute : Attribute
    {
    }
}";

        public void Initialize(GeneratorInitializationContext context)
        {
            // Inject the attribute source into the compilation
            context.RegisterForPostInitialization((i) => i.AddSource("YiniBindableAttribute.g.cs", AttributeText));

            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // Retrieve the populated receiver
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            // Get the compilation and the attribute symbol
            Compilation compilation = context.Compilation;
            INamedTypeSymbol attributeSymbol = compilation.GetTypeByMetadataName("Yini.YiniBindableAttribute");

            foreach (ClassDeclarationSyntax classSyntax in receiver.CandidateClasses)
            {
                SemanticModel model = compilation.GetSemanticModel(classSyntax.SyntaxTree);
                if (!(model.GetDeclaredSymbol(classSyntax) is INamedTypeSymbol classSymbol))
                    continue;

                // Check if the class has the [YiniBindable] attribute
                if (classSymbol.GetAttributes().Any(ad => ad.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default)))
                {
                    string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
                    var source = GenerateBinderClass(classSymbol, namespaceName);
                    context.AddSource($"{classSymbol.Name}_YiniBinder.g.cs", SourceText.From(source, Encoding.UTF8));
                }
            }
        }

        private string GenerateBinderClass(INamedTypeSymbol classSymbol, string namespaceName)
        {
            var className = classSymbol.Name;
            var properties = classSymbol.GetMembers().OfType<IPropertySymbol>()
                                       .Where(p => p.SetMethod != null && p.GetMethod != null);

            var sb = new StringBuilder();
            sb.Append($@"// <auto-generated/>
using Yini;
using System.Collections.Generic;

namespace {namespaceName}
{{
    public partial class {className}
    {{
        /// <summary>
        /// Binds data from a YINI file to this instance using a high-performance,
        /// reflection-free method generated at compile time.
        /// </summary>
        public void BindFromYini(YiniManager manager, string section)
        {{
");

            foreach (var prop in properties)
            {
                var propType = prop.Type as INamedTypeSymbol;
                if (propType == null) continue;

                var keyAttr = prop.GetAttributes().FirstOrDefault(ad => ad.AttributeClass.Name == "YiniKeyAttribute");
                string yiniKey = keyAttr?.ConstructorArguments.FirstOrDefault().Value?.ToString() ?? prop.Name.ToLower();

                string bindingMethod = GetBindingMethod(propType, yiniKey);
                if (bindingMethod != null)
                {
                    // Check if the property is a non-nullable value type
                    bool isNonNullableValueType = propType.IsValueType && !(propType.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T);

                    if (isNonNullableValueType)
                    {
                        // For non-nullable value types, assign directly. The Get... method handles the default.
                        sb.AppendLine($"            this.{prop.Name} = {bindingMethod};");
                    }
                    else
                    {
                        // For reference types and nullable value types, use the null-coalescing operator
                        // to keep the existing property value if the binding method returns null.
                        sb.AppendLine($"            this.{prop.Name} = {bindingMethod} ?? this.{prop.Name};");
                    }
                }
            }

            sb.Append(@"
        }
    }
}
");
            return sb.ToString();
        }

        private string GetBindingMethod(INamedTypeSymbol propType, string yiniKey)
        {
            string typeName = propType.ToDisplayString();

            if (propType.IsGenericType && (propType.Name == "List" || propType.Name == "IList") && propType.TypeArguments.Length == 1)
            {
                var elementType = propType.TypeArguments[0];
                return $"manager.GetList<{elementType.ToDisplayString()}>(section, \"{yiniKey}\")";
            }

            if (propType.IsGenericType && (propType.Name == "Dictionary" || propType.Name == "IDictionary") && propType.TypeArguments.Length == 2 && propType.TypeArguments[0].SpecialType == SpecialType.System_String)
            {
                var valueType = propType.TypeArguments[1];
                return $"manager.GetDictionary<string, {valueType.ToDisplayString()}>(section, \"{yiniKey}\")";
            }

            switch (typeName)
            {
                case "string":
                case "System.String":
                    return $"manager.GetString(section, \"{yiniKey}\", default)";
                case "bool":
                case "System.Boolean":
                    return $"manager.GetBool(section, \"{yiniKey}\", default)";
                case "int":
                case "System.Int32":
                    return $"(int)manager.GetDouble(section, \"{yiniKey}\", default)";
                case "float":
                case "System.Single":
                    return $"(float)manager.GetDouble(section, \"{yiniKey}\", default)";
                case "double":
                case "System.Double":
                    return $"manager.GetDouble(section, \"{yiniKey}\", default)";
                default:
                    return null;
            }
        }
    }

    /// <summary>
    /// Created on demand before each generation pass
    /// </summary>
    class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

        /// <summary>
        /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
        /// </summary>
        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Any class with at least one attribute is a candidate for generation
            if (syntaxNode is ClassDeclarationSyntax classDeclarationSyntax
                && classDeclarationSyntax.AttributeLists.Count > 0)
            {
                CandidateClasses.Add(classDeclarationSyntax);
            }
        }
    }
}
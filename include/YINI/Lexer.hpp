/**
 * @file Lexer.hpp
 * @brief Defines the lexical analyzer for the YINI language.
 */

#ifndef YINI_LEXER_HPP
#define YINI_LEXER_HPP

#include <string>
#include <vector>

namespace YINI
{
/**
 * @enum TokenType
 * @brief Enumerates all possible token types in the YINI language.
 */
enum class TokenType
{
  Eof,          ///< End of file.
  Section,      ///< A section name (legacy, now uses Identifier).
  Key,          ///< A key name (legacy, now uses Identifier).
  Value,        ///< A value (legacy, now uses more specific types).
  Equals,       ///< The '=' character.
  Comment,      ///< A line or block comment.
  String,       ///< A double-quoted string literal.
  Number,       ///< An integer or floating-point number.
  Boolean,      ///< A 'true' or 'false' literal.
  LeftBracket,  ///< The '[' character.
  RightBracket, ///< The ']' character.
  LeftParen,    ///< The '(' character.
  RightParen,   ///< The ')' character.
  LeftBrace,    ///< The '{' character.
  RightBrace,   ///< The '}' character.
  Comma,        ///< The ',' character.
  Plus,         ///< The '+' character.
  Minus,        ///< The '-' character.
  Star,         ///< The '*' character.
  Slash,        ///< The '/' character.
  Percent,      ///< The '%' character.
  Colon,        ///< The ':' character.
  PlusEquals,   ///< The '+=' characters for quick registration.
  At,           ///< The '@' character for macro references.
  Hash,         ///< The '#' character for directives.
  HexColor,     ///< A hex color code, e.g., #RRGGBB.
  Identifier,   ///< A generic identifier (e.g., section names, keys, function names).
  Unknown       ///< An unrecognized token.
};

/**
 * @struct Token
 * @brief Represents a token generated by the Lexer.
 */
struct Token
{
  TokenType type;      ///< The type of the token.
  std::string value;   ///< The string value of the token.
  int line;            ///< The line number where the token starts.
  int column;          ///< The column number where the token starts.
};

/**
 * @class Lexer
 * @brief A lexical analyzer that converts a raw string into a stream of tokens.
 */
class Lexer
{
public:
  /**
   * @brief Constructs a new Lexer.
   * @param input The raw string content of the YINI file to tokenize.
   */
  Lexer(const std::string &input);

  /**
   * @brief Scans the input string and returns the next token.
   * @return The next Token in the stream.
   */
  Token getNextToken();

private:
  void skipWhitespace();
  void skipComment();
  void skipBlockComment();
  Token parseString();
  Token parseNumber();
  Token parseIdentifier();

  std::string inputStr; ///< The input string being tokenized.
  size_t position;      ///< The current character position in the input string.
  int line_num;         ///< The current line number.
  int column_num;       ///< The current column number.
};
} // namespace YINI

#endif // YINI_LEXER_HPP